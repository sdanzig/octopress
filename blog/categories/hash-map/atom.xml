<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hash map | The Programmer's Probe]]></title>
  <link href="http://sdanzig.github.io/blog/categories/hash-map/atom.xml" rel="self"/>
  <link href="http://sdanzig.github.io/"/>
  <updated>2013-08-07T08:56:55-04:00</updated>
  <id>http://sdanzig.github.io/</id>
  <author>
    <name><![CDATA[Scott Danzig]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Optimization of Java's HashMap class]]></title>
    <link href="http://sdanzig.github.io/blog/2013/06/27/the-optimization-of-javas-hashmap/"/>
    <updated>2013-06-27T00:00:00-04:00</updated>
    <id>http://sdanzig.github.io/blog/2013/06/27/the-optimization-of-javas-hashmap</id>
    <content type="html"><![CDATA[<div class='post'>
Yesterday I was on Quora.com sifting through some Q&amp;A and I ran across someone describing an optimization that was made in Java's HashMap class, according to the poster around version 1.4. &nbsp;It was simple, yet it amazed me. &nbsp;I didn't understand how it could work at first, but with a little digging, I figured it out, and it's simple yet very clever. &nbsp;First I'll briefly explain some of how a hash map works, for the laymen (I think everyone can understand most of this), then I'll go on to describe the change.<br /><br /><br /><h3>Description of What a Hash Map is</h3>A hash map is a way a computer can store a set of things in memory for quick access. &nbsp;Picture I had a function that took a word, let's say "bird", and converted it to a number, such as 7. &nbsp;As long as you had the same input, you'd always get the same output. &nbsp;So when you wanted to access a bunch of information with the label "bird", you can find it in storage bin number 7. &nbsp;You only have to look in one bucket, so it's super-fast.<br /><br />Optimally, your function will have a unique number for every unique word. &nbsp;Ideally it would, but the function might not be perfect, and if "bird" and "potato" both produce a 7, then if you want to look up either, you might have to check two spots in memory instead of one, which takes longer. &nbsp;This is called a "collision", and you want a function that avoids them as much as possible.<br /><br />Now, it's true that if you had a billion words, it's unrealistic that your computer could have a billion separate spots in memory to hold it. &nbsp;But your function produces unique numbers for nearly all of them, so you ultimately want the hash map to have a place for each number. &nbsp;What a HashMap will do is take the number of spots in memory it DOES have (let's say 16), and divide the number output of the function by it, and use the remainder instead. &nbsp;This is the "modulo operation", represented by the percent (%) sign. &nbsp;That way, you're never trying to put something in a memory location that your hash map can't support. &nbsp;So if your function said "banana" should go in spot 39, then you'd see 39 % 16 = 7.<br /><br />Certainly you're going to have plenty of collisions, but there are a couple of key optimizations that can be made. &nbsp;First, you want the function to spit out numbers that are as evenly distributed as possible, so you don't have a bad scenario where you're searching through most of the words because they all resulted in, for instance, the number 7. &nbsp;There are formulas provided by others who have thought this through already, so just use those. &nbsp;Secondly, when the hash map gets too full, it will increase the number of spaces available, and move all the old words to their new locations based on the new number of "spots".<br /><br />Just so you can talk the talk, the spots in memory a hash map has available are called "buckets". &nbsp;The function that converts words to numbers is called a "hash function". &nbsp;The numbers are called "hash codes". &nbsp;The words are called "keys", and the "bunch of information" attached to a key is called a "value".<br /><br /><br /><h3>Java's Hash Map Optimization</h3><br /><script src="https://gist.github.com/sdanzig/5901481.js"></script> The above modification shows the change, but it's dependent on a couple of other behaviors of the Java hash map. &nbsp;First, I'll review what's going on. &nbsp;I mentioned how modulo is used to determine what bucket a specific hash code maps to. &nbsp;This is replacing that modulo with a "bitwise AND". &nbsp;I'm not going to review too much about binary here, but it's all 1's and 0's instead of 0-9 like the base-10 (decimal) numbers you're used to. &nbsp;So if you have 1 &amp; 1, you get 1. &nbsp;But if either or both is a 0, you get 0. &nbsp;Picture converting the hash code and the number of buckets to a bunch of 1 and 0 "bits", then doing this AND operation on each bit, from right (least significant/smallest) to left.<br /><br />If you think about it, you might wonder how this works, because it's not the same thing as modulo. &nbsp;If you have 5 buckets, you're converting 4 to binary -- 100 (google "4 in binary"). &nbsp;That means whatever your hash code is, only the third bit will matter because the other bits will be ANDed to 0. &nbsp;indexFor will always output either a 0 or a 4. &nbsp;That will be a crazy amount of collisions.<br /><br /><h4>First Trick</h4><br />There will never <b>be</b> 5 buckets. &nbsp;Java's hash map implementation, when expanding, multiplies the number of buckets by 2. &nbsp;You'll always have a power of 2 (1, 2, 4, 8, 16, etc). &nbsp;When you convert a power of 1 to binary, you only have one bit as a 1. &nbsp;When you subtract 1 from a power of 2 and convert that to binary, that bit is a 0, and all the bits to the right of it are 1. &nbsp;Try ANDing a bunch of 1's with anything and you get the modulo of what those 1's represent in decimal plus 1. &nbsp;ANDing bits like this is much faster than doing a modulo, which requires division and subtraction.<br /><br /><h3>Second Trick</h3><br />There's also a concern which might not be obvious, but if you are relying on only the smallest bits of your hash code, you can easily get an uneven distribution of keys in your buckets unless you have a really good hash function. &nbsp;What Java's hash map implementation does is to "rehash" the hash code. &nbsp;Check this out:<br /><br /><script src="https://gist.github.com/sdanzig/5901495.js"></script> <br />This scary thing takes your mostly unique hash code and randomizes it in a way that has a relatively even distribution in the "lower bits". &nbsp;For curiosity's sake, I'll mention that the &gt;&gt;&gt; is shifting the bits in your hash code to the right... so if you had a 4, or 100 in binary, and you did 4 &gt;&gt;&gt; 2, you'd end up with 001, because it's been right-shifted twice. &nbsp;The ^ is an "exclusive OR" operation, which is similar to the AND operation, but it outputs a 1 if the two bits are different (one's a 1, and the other is 0). &nbsp;Essentially this thing is ensuring that the more significant bits in your hash code are affecting the least significant bits that you're ultimately going to use to choose each bucket.<br /><br /><br />Hope you found this all as righteous as I did!</div>

]]></content>
  </entry>
  
</feed>
