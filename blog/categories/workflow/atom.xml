<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: workflow | The Programmer's Probe]]></title>
  <link href="http://sdanzig.github.io/blog/categories/workflow/atom.xml" rel="self"/>
  <link href="http://sdanzig.github.io/"/>
  <updated>2013-08-07T09:00:57-04:00</updated>
  <id>http://sdanzig.github.io/</id>
  <author>
    <name><![CDATA[Scott Danzig]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to Git Along with a Sensible Git Workflow]]></title>
    <link href="http://sdanzig.github.io/blog/2013/07/07/introduction-to-git-along-with-sensible/"/>
    <updated>2013-07-07T00:00:00-04:00</updated>
    <id>http://sdanzig.github.io/blog/2013/07/07/introduction-to-git-along-with-sensible</id>
    <content type="html"><![CDATA[<div class='post'>
<style>.post-body img, .post-body .tr-caption-container, .ss, .Profile img, .Image img, .BlogList .item-thumbnail img {   padding: none !important;   border: none !important;   background: none !important;   -moz-box-shadow: 0px 0px 0px transparent !important;   -webkit-box-shadow: 0px 0px 0px transparent !important;   box-shadow: 0px 0px 0px transparent !important; } </style> <br /><span style="font-size: x-small;"><i>An initial note: &nbsp;I learned about Git initially with the book&nbsp;<a href="http://git-scm.com/book">Pro Git</a>&nbsp;which I'm amazed is freely available online, so if you want a more comprehensive overview, check that out.<br /><br />Also, I'd like to amend this post by saying, for change/commit descriptions, it's best practice to use the imperative style. (e.g. "Add file A", rather than "Added file A"). It's too late for me to update all these screenshots.</i></span><br /><div><br /><h3>Table of Contents</h3></div><div><a href="#what-is-a-version-control-system">What is a Version Control System?</a></div><div><a href="#overview-of-this-article">Overview of This Article</a></div><div><a href="#key-benefits-of-git">Key Benefits of Git</a></div><div><ul><li><a href="#other-notable-features">Other Notable Features</a></li></ul></div><div><a href="#tutorial">Tutorial</a></div><div><ul><li><a href="#setup">Setup</a></li><li><a href="#clone-a-repository">Clone a Repository</a></li><li><a href="#folder-structure">Folder Structure</a></li><li><a href="#git-log">git log</a></li><li><a href="#the-gitignore-file-and-git-status">The .gitignore File, and "git status"</a></li><li><a href="#staging-changes-you-want-to-commit">Staging Changes You Want to Commit</a></li><li><a href="#committing-changes-to-your-repository">Committing Changes to Your Repository</a></li><li><a href="#the-origin">The Origin</a></li><li><a href="#branches">Branches</a></li><li><a href="#pushing-to-the-remote-repository">Pushing to the Remote Repository</a></li><li><a href="#pulling-changes-from-the-remote-repository">Pulling Changes from the Remote Repository</a></li><li><a href="#merges-and-conflicts">Merges and Conflicts</a></li><li><a href="#rebasing">Rebasing</a></li><li><a href="#pull-requests">Pull Requests</a></li></ul></div><div><a href="#new-york-magazine-development-environment">New York Magazine Development Environment</a><br /><a href="#my-preferred-workflow-with-git">My Preferred Workflow with Git</a></div><div><ul><li><a href="#changing-the-code">Changing the Code</a></li><li><a href="#submitting-to-qa">Submitting to QA</a></li><li><a href="#the-project-maintainer">The Project Maintainer</a></li><li><a href="#release-day">Release Day</a></li><li><a href="#whats-not-set-in-stone">What's Not Set in Stone</a></li></ul><a href="#conclusion">Conclusion</a></div><div><br /></div><br /><h3 id="what-is-a-version-control-system">What is a Version Control System?</h3><br />A version control system allows you to store different versions of your code as you make changes. &nbsp;This allows you to avoid losing your changes, and access your code from a convenient location on the internet. &nbsp;You can keep some changes separate in its own branch, and merge those changes into the master branch when you're ready, so the main version of your code is unaffected until you know your changes function properly. &nbsp;In case you're unfamiliar with the term "branch", picture it as a particular version of your entire project. &nbsp;Let's say you're working on a book, and you have a published version, and a "work in progress" version. &nbsp;You are rewriting a chapter of your book in the "work in progress" section, but you still have the published version separate, so if you want to print out a copy of your book without the partially modified chapter, you can. &nbsp;When you're done modifying that chapter, you can merge in your changes to the published version, deleting the modification branch afterward. &nbsp;You could also have a permanent "student edition" branch that has more detail, and perhaps exercises at the end of each chapter. &nbsp;You can easily merge the same changes into that branch to keep it up to date, but maintain a separate copy.<br /><br /><h3><span id="overview-of-this-article"></span>Overview of This Article</h3><br />I haven't been particularly inspired by any version control system until I dove into Git, created by the founder of Linux, Linus Torvalds. &nbsp;If you're already familiar with Git, feel free to skip the tutorial sections. &nbsp;I'm going to go over the following:<br /><br /><ul><li>Summarize what sets Git apart from other alternatives</li><li>The basics of Git, so someone new to Git can be productive with it</li><li>How it's set up at New York Magazine, where I work</li><li>My preferred workflow using Git</li></ul><br /><h3><span id="key-benefits-of-git"></span>Key Benefits of Git</h3><br /><ul><li>When you create a new branch, Git doesn't copy all your files over. &nbsp;A branch will point to the original files and only track the changes (commits) specific to that branch. &nbsp;This makes it blazingly fast, as opposed to its main competitor in terms of marketshare, Subversion, which actually laboriously copies the files.</li><li>Git lets you work on your own copy of a project, merging your commits into the central repository, often on github.com, when you want your commits to be available to others. &nbsp;Github.com, by the way, will host your project, for free as long as it's open source. &nbsp;This means you can reliably access your code from anywhere with an internet connection. &nbsp;If you lose that internet connection, you can continue to work locally and sync up your changes when you're able to reconnect.</li><li>When you screw up, you can usually undo your changes, somehow. &nbsp;You might need to call in an expert in serious cases, but there's always hope. &nbsp;This is the best "key benefit" a version control system can have.</li><li>Git also lets you keep your commit history very organized. &nbsp;If you have lots of little changes, it lets you easily rewrite history so you see it as one big change (via something called rebasing). &nbsp;You can add/remove files in each commit, and certainly change the descriptions of each. &nbsp;This definitely forces me to consciously repress OCD tendencies.</li><li>It's open source, fast, and very flexible, so it's widely-adopted and therefore well-supported.</li></ul><br /><div><br /></div><div><h4><span id="other-notable-features"></span>Other Notable Features</h4></div><div><br /></div><div><ul><li>With Git, you can create "hooks", which let things happen automatically when you work with your code. &nbsp;A common usage is to create a hook to check the description submitted with each commit, making sure it conforms to a particular format. &nbsp;Perhaps you have your bugs described in a bug tracking system and each bug has an ID #. &nbsp;Git can ensure each message has "Bug: SomeNumber".</li><li>Another&nbsp;under-appreciated&nbsp;feature is how Git tracks files. &nbsp;It uses an algorithm called SHA-1 to take the contents of files and produce a large hexadecimal number (hash code). &nbsp;The same file will always produce the same hash code. &nbsp;This way, if you move a file to a different folder, it can detect that the file moved, and not think that you deleted one file and added another. &nbsp;This allows Git to not have to keep two copies of the same file.</li><li>While Git is not necessarily the most intuitive version control system out there, once you get used to it, you're able to browse through its internal directories and it all makes complete sense. &nbsp;Wondering where the file with the hash code "d482acb1302c49af36d5dabe0bccea04546496f7" is? &nbsp;Check out this file: &nbsp;"&lt;your project&gt;/.git/objects/d4/82acb1302c49af36d5dabe0bccea04546496f7" &nbsp;See how where the file is stored is determined by the hash code? &nbsp;There are lots of lower-level commands that let you build the operations you want, in case, for instance, git's merge command doesn't work how you'd like it to.</li></ul></div><div><br /></div><div><h3><span id="tutorial"></span>Tutorial</h3><br />So you're, in whatever programming language, going to start a new project, and you want to use version control? &nbsp;I'm going to just create a silly, sample application in Scala that's very easy to understand, to demonstrate. &nbsp;I'm going to assume you're familiar with your operating system's command-line interface, and that you're able to write something in the language of your choice.<br /><br /><h4><span id="setup"></span>Setup</h4><br />Github is one of the go-to places to get your code hosted for free. &nbsp;It gives you a home for your code, that you can access from anywhere. &nbsp;Initial steps:<br /><br /><ol><li>Go to http://github.com and "Sign up for Github"</li><li>You'll need Git. &nbsp;Follow this page step by step: &nbsp;http://help.github.com/articles/set-up-git</li><li>This explains how to create a new repository: &nbsp;https://help.github.com/articles/create-a-repo</li><li>Lastly, you're going to want to get used to viewing files that start with a "." &nbsp;These files are hidden by default, so at the command line, when you're listing contents of a directory, you need to include an "a" option. &nbsp;That's "ls -a" in OSX and Linux, and "dir /a" for Windows. &nbsp;In your folder options, you can turn on "Show hidden files and folders" as well.</li></ol><br />Once you got that far, there's nothing stopping you, outside of setting aside some play time, from using everything git has to offer.<br /><br /><h4><span id="clone-a-repository"></span>Clone a Repository</h4><br />Cloning a repository lets you grab the source code from an existing project that you own, or someone else's project that you have access to (usually public). &nbsp;Unless it's your project, you won't be able to make changes, so you're going to "fork" my potayto project, which means to create your own copy of it under your own account, then you can modify that to your heart's content. &nbsp;I keep all of my projects locally (on my computer) in a "projects" folder in my home directory, "/Users/sdanzig/projects", so I'm going to use "projects" for this demo.<br /><br />First, fork my repository...<br /><br />I created a sample project on github, as you now should know how to do. <br /><br /><div style="text-align: left;"></div>Let's get this project onto your hard drive, so you can add comments to my source code for me!<br /><br />First, log into your github account, then go to my repository at&nbsp;https://github.com/sdanzig/potayto &nbsp;... Click "Fork":<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-oyjDU8E8zuc/UdcXi1mcgLI/AAAAAAAACM8/f0wyCmDHGJk/s1600/fork_repo.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="332" src="http://4.bp.blogspot.com/-oyjDU8E8zuc/UdcXi1mcgLI/AAAAAAAACM8/f0wyCmDHGJk/s640/fork_repo.jpg" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 1</td></tr></tbody></table><br />Then select your user account, to copy it to. &nbsp;At this point, it's as though it were your own repository, and you can actually make changes in the code on github. &nbsp;We're going to copy the repository onto our local hard drive, so we can both edit and compile the code there.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-Umank7K0BVM/UdcdgXAI1kI/AAAAAAAACNM/1ducWTeY1NY/s1600/clone_repo.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-Umank7K0BVM/UdcdgXAI1kI/AAAAAAAACNM/1ducWTeY1NY/s1600/clone_repo.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 2</td></tr></tbody></table><br /><h4><span id="folder-structure"></span>Folder structure</h4>There are a few key things to know about what git is doing with your files. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">cd potayto</span></blockquote>There are a couple things to see here. &nbsp;List the contents in the potayto folder, being careful to show the hidden files and folders:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/--c_IrW5WmaU/Udcx2_1OZjI/AAAAAAAACNc/zgsExmHzFoE/s1600/list_folder.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/--c_IrW5WmaU/Udcx2_1OZjI/AAAAAAAACNc/zgsExmHzFoE/s1600/list_folder.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 3</td></tr></tbody></table><br />The src folder has the source code, and its structure conforms to the&nbsp;<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html">Maven standard directory structure</a>. &nbsp;You'll also see a .git folder, which contains a complete record of all the changes that were made to the potayto project.the potayto repository and also a .gitignore text file. &nbsp;We're not going to dive into the contents of .git in this tutorial, but it's easier to understand than you think. &nbsp;If you're curious, please refer to the <a href="http://git-scm.com/book">online book I mentioned earlier</a>.<br /><br /><span id="git-log"></span><br /><h4>git log</h4>A "commit" is a change recorded in your repository. &nbsp;Type "git log", and you might have to press your space bar to scroll and type "q" at the end, to quit displaying the file:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-CTyANoaQ2WY/UddMy9ADuNI/AAAAAAAACOU/il4gGjNApno/s1600/git_log.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-CTyANoaQ2WY/UddMy9ADuNI/AAAAAAAACOU/il4gGjNApno/s1600/git_log.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 4</td></tr></tbody></table><br />Git's log shows the potayto project has 3 commits so far, from oldest on bottom, the first commit, to most recent on top. &nbsp;You see the big hexadecimal numbers preceded by the word "commit"? &nbsp;Those are the SHA codes I was referring to. &nbsp;Git also uses these SHA codes to identify commits. &nbsp;They're big and scary, but you can just copy and paste them. &nbsp;Also, you only need to type enough letters and numbers for it to be uniquely identified. &nbsp;Five should be usually enough. &nbsp;For this project, you can get away with 4, the minimum.<br /><br />Let's see how my first commit started. &nbsp;To see the details of the first commit, ype:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git show bfaa</span></blockquote><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-K5pLhXsnwtE/UdeB7YMiPCI/AAAAAAAACO0/S1ZqCYDhj9I/s1600/show_first_commit.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-K5pLhXsnwtE/UdeB7YMiPCI/AAAAAAAACO0/S1ZqCYDhj9I/s1600/show_first_commit.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 5</td></tr></tbody></table><br />Initially I checked in my Scala application as something that merely printed out "Tomayto tomahto," "Potayto potahto!" &nbsp;You can see that near the bottom. &nbsp;The "main" method of the "Potayto" object gets executed, and there are those two "print lines". &nbsp;Earlier in the commit you can see the addition of the .gitignore I provided. &nbsp;I'm making git ignore my Eclipse-specific dot-something files (e.g. .project) and also the target directory, where my source code get compiled to. &nbsp;Git's show command is showing the changes in the file, not the entire files. &nbsp;Those +'s before each line mean the lines were added. &nbsp;In this case, they were added because the file was previously non-existant. &nbsp;That's why you see the /dev/null there.<br /><br />Now type:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git show 963e</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-Up2NjEISAQ0/UdeE7eeiX6I/AAAAAAAACPE/aMgu_uBr-Ak/s1600/show_second_commit.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-Up2NjEISAQ0/UdeE7eeiX6I/AAAAAAAACPE/aMgu_uBr-Ak/s1600/show_second_commit.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 6</td></tr></tbody></table><br />Here you see my informative commit message about what changed, which should be concise but comprehensive, so you're able to find the change when you need it. &nbsp;After that, you see that I did exactly what the message says. &nbsp;I changed the order of the lyrics. &nbsp;You see two lines beginning with "-", preceding the lines removed, and two lines beginning with "+", preceding the lines added. &nbsp;You get the idea.<br /><span id="the-gitignore-file-and-git-status"></span><br /><h4>The .gitignore File, and "git status"</h4>View the .gitignore file.<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">.cache</span><br /><span style="font-family: Courier New, Courier, monospace;">.settings</span><br /><span style="font-family: Courier New, Courier, monospace;">.classpath</span><br /><span style="font-family: Courier New, Courier, monospace;">.project</span><br /><span style="font-family: Courier New, Courier, monospace;">target</span><br /></blockquote>This is a manually created file that tells git what to ignore. &nbsp;If you don't want files tracked, you include it here. &nbsp;I use software called Eclipse to write my code, and it creates hidden project files which git will see and want to add in to the project. &nbsp;Why should you be confined to using not only the same software as me to mess with my code, but also the same settings? &nbsp;Some teams might want to conform to the same development environments and checking in the project files might be a time saver, but these days there are tools that let you easily generate such project files for popular IDEs. &nbsp;Therefore, I have git ignore all the eclipse-specific files, which all happen to start with a "."<br /><br />There's also a "target" folder. &nbsp;I've configured Eclipse to write my compiled code into that folder. &nbsp;We don't want git tracking the files generated upon compilation. &nbsp;Let those grabbing your source code compile it themselves after they make what modifications they wish. &nbsp;You're going to want to create one for your own &nbsp;projects. &nbsp;This .gitignore file gets checked in along with your project, so people who modify your code don't accidentally check in their generated code as well. &nbsp;Others might be using Intellij, which writes .idea folders and .ipr and .iws files, so they may append this to the .gitignore, which is completely fine.<br /><br />Let's try this. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-LeGJu8Vs2H8/Udc02oIosNI/AAAAAAAACNs/g3KmVTbfccw/s1600/first_git_status.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-LeGJu8Vs2H8/Udc02oIosNI/AAAAAAAACNs/g3KmVTbfccw/s1600/first_git_status.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 7</td></tr></tbody></table><br />You'll see you're on the main branch of your project (a version of your code), "master". &nbsp;Being "on a branch" means your commits are appended to that branch. &nbsp;Now create a text file named "deleteme.txt" using whatever editor you want in that potayto folder and type "git status" again:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-rChp38Fcntc/Udc3X1v_AEI/AAAAAAAACN8/6eWdY0jqhDo/s1600/deleteme.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-rChp38Fcntc/Udc3X1v_AEI/AAAAAAAACN8/6eWdY0jqhDo/s1600/deleteme.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 8</td></tr></tbody></table><br />Use that same text editor to add "deleteme.txt" as the last line of .gitignore and check this out:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-IC-dqJwh3bk/Udc4G6lu2JI/AAAAAAAACOE/SsR57dhdMV4/s1600/deleteme_removed.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-IC-dqJwh3bk/Udc4G6lu2JI/AAAAAAAACOE/SsR57dhdMV4/s1600/deleteme_removed.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 9</td></tr></tbody></table><br />See, you modified .gitignore, so git doesn't see your deleteme.txt file. &nbsp;However, other than this nifty feature, .gitignore is a file just like any other file in your repository, so if you want this "ignoring" saved, you have to commit the change, just like you would commit a change to your code.<br /><br /><span id="staging-changes-you-want-to-commit"></span><br /><h4>Staging Changes You Want to Commit</h4><br />Here's one of the fun things with git. &nbsp;You can "stage" the modified files that you want to commit. &nbsp;Other version control systems ominously await your one command before your files instantly changed in the repository, perhaps the remote repository for the entire team.<br /><br />Let's say you wanted to make a change involving files A and B. &nbsp;You changed file A. &nbsp;You then remembered something you'd like to do with file Z, on an unrelated note, and modified that before you forgot about it. &nbsp;Then you completed your initial change, modifying file B. &nbsp;Git allows you to "add" files A and B to staging, while leaving file Z "unstaged". &nbsp;Then you can "commit" only the staged files to your repository. &nbsp;But you don't! &nbsp;You realize you need to make a change to file C as well. &nbsp;You "add" it. &nbsp;Now files A, B, and C are staged, and Z is still unstaged. &nbsp;You commit the staged changes only.<br /><br />Read that last paragraph repeatedly if you didn't follow it fully. &nbsp;It's important. &nbsp;See how Git lets you prepare your commit beforehand? &nbsp;With a version control system such as Subversion, you'd have to remember to make your change to file Z later, and your "commit history" would show that you changed files A and B, then, in another entry, that you changed file C later.<br /><br />We won't be as intricate. &nbsp;Let's just stage our one file for now. &nbsp;Look at Figure 9. &nbsp;Git gives you instructions for what you can do while in the repository's current state. &nbsp;Git is not known for having intuitive commands, but it <b>is</b> known for helping you out. &nbsp;"git checkout -- .gitignore" to undo your change? &nbsp;It's strange, but at least it tells you exactly what to do.<br /><br />To promote .gitignore to "staged" status, type<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git add .gitignore</span></blockquote><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-5d82j-szPl0/UdeRg0gREOI/AAAAAAAACPU/NhWo1yZkoFs/s1600/staged_file.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-5d82j-szPl0/UdeRg0gREOI/AAAAAAAACPU/NhWo1yZkoFs/s1600/staged_file.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 10</td></tr></tbody></table><br />The important thing to note here is that now your file change is listed under "Changes to be committed" and git is spoon-feeding you what exactly you need to type if you want to undo this staging. &nbsp;Don't type this:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git reset HEAD .gitignore</span></blockquote>You should strive to understand what's going on there (check out the Pro Git book I linked to for those details) but for now, in this situation, you just are given means to an end when you might need it (changing your mind about what to stage).<br /><br />By the way, it's often more convenient to just type "<span style="font-family: Courier New, Courier, monospace;">git add &lt;folder name&gt;</span>" to add all modifications of files in a folder (and subfolders of that folder). &nbsp;Also very common to type is "<span style="font-family: Courier New, Courier, monospace;">git add .</span>", a shortcut to stage all the modified files in your repository. &nbsp;This is fine as long as you're sure you're not accidentally adding a file such as Z that you don't want to be grouped into this change in your commit history.<br /><br /><i><span style="font-size: x-small;">It's also useful to know how to stage the deletion of a file. &nbsp;Use "git rm &lt;file&gt;" for that.</span></i><br /><br /><span id="committing-changes-to-your-repository"></span><br /><h4>Committing Changes to Your Repository</h4><br />Guess what? &nbsp;We get to do our first commit! &nbsp;Time to make that .gitignore change official. &nbsp;Type:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -m "Added deleteme.txt to .gitignore"</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-xoGheNpaLAs/UdeXmnhDO1I/AAAAAAAACPk/LEujMur9W2c/s1600/make_first_commit.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-xoGheNpaLAs/UdeXmnhDO1I/AAAAAAAACPk/LEujMur9W2c/s1600/make_first_commit.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 11</td></tr></tbody></table><br />You could just type "git commit", but then git would load up a text editor, and you'd be required to type a commit message anyway. &nbsp;In OSX and Linux, "vim" would load up, and in Windows, you'd get an error. &nbsp;If you prefer a full screen editor in Windows, you can type this to configure it:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git config --global core.editor "notepad"</span></blockquote><br /><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://nostarch.com/sites/default/files/imagecache/product_full/mug_vi.jpg" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="200" src="http://nostarch.com/sites/default/files/imagecache/product_full/mug_vi.jpg" width="198" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Mug available on thinkgeek.com<br />sporting some vi quick reference.<br />Vim supports all vi commands listed.</td></tr></tbody></table>If you end up in vim and are unfamiliar with it, realize it's a very geeky and unintuitive but powerful editor to use. &nbsp;In general, pressing the escape key, and typing ":x" will save what you're writing and then exit. &nbsp;The same syntax will work to choose a new full screen editor in OSX and Linux, of course replacing notepad with the /full/path/and/filename of a different editor.<br /><br />The full screen editor is necessary if you want a commit message with multiple lines, or in other situations, so if you hate vim, configure git to one you do like.<br /><br />Enough with this babble. &nbsp;Fill that VI mug with champagne -- you just made your first commit! &nbsp;If you can contain your excitement, type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-dKeAGdNnZKM/UdeaE_lxbSI/AAAAAAAACP0/tiXR-AVoSvQ/s1600/git_log_with_commit.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-dKeAGdNnZKM/UdeaE_lxbSI/AAAAAAAACP0/tiXR-AVoSvQ/s1600/git_log_with_commit.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 12</td></tr></tbody></table>The change on top is yours. &nbsp;Oh, what the heck, let's take a look at it:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-T9B6aeqkoGo/UdfAEG-BujI/AAAAAAAACQE/ezkm_6zGG8U/s1600/git_show_new_change.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-T9B6aeqkoGo/UdfAEG-BujI/AAAAAAAACQE/ezkm_6zGG8U/s1600/git_show_new_change.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 13</td></tr></tbody></table><br />See the +deleteme.txt there? &nbsp;That was you! &nbsp;The way this "diff" works is that git tries to show you three lines before and after each of your changes. &nbsp;Here, there were no lines below your addition. The -3,3 and +3,4 are ranges. &nbsp;- precedes the old file's range, and + is for the new file. &nbsp;The first number in each range is a starting line number. &nbsp;The second number is the number of lines of the displayed sample before and after your modification. &nbsp;The 4 lines displayed only totaled 3 before your change.<br /><br /><span style="font-size: x-small;"><i>If you want to revert changes you made, the safest way is to use "git revert", which automatically creates a new commit that undoes the changes in another commit. &nbsp;Don't do this, but if you wanted to undo that "deleteme.txt ignoring" commit which has the SHA starting with 0c22, you can type: "git revert 0c22"</i></span><br /><span id="the-origin"></span><br /><h4>The Origin</h4><br />You cloned your repository from your github account. &nbsp;Unless something went horribly wrong, this should be:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">https://github.com/&lt;your github username&gt;/potayto.git</span></blockquote>Git automatically labels where you cloned a repository from as "origin". &nbsp;Remember when I said the internals of a git repository were easily accessible in that .git folder in your project? &nbsp;Look at the text file .git/config:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-28uUud2GVJk/Udg9OfKkubI/AAAAAAAACQU/tphwBdve8Hs/s1600/git_config.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-28uUud2GVJk/Udg9OfKkubI/AAAAAAAACQU/tphwBdve8Hs/s1600/git_config.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 14</td></tr></tbody></table><br />It's as simple as this. <br /><br /><span id="branches"></span><br /><h4>Branches</h4><br />Before I explain how to make your changes on the version of your code stored on github, I should first explain more about branches. &nbsp;I already explained how a branch is a separate version of your code. &nbsp;A change made to one branch does not affect the version of your repository represented by the other branch, unless you explicitly merge the change into it. &nbsp;By default, git will put your code on a "master" branch. &nbsp;When you clone a project from a remote repository (remote in this case means hosted by github), it will automatically create a local branch that "tracks" a remote branch. &nbsp;Tracking a branch means that git will help you easily determine:<br /><br /><ul><li>See the differences between commits made to the tracking branch (the local one) and the tracked branch (remote)</li><li>Add your new local commits to the remote branch</li><li>Put the new remote commits on your local branch</li></ul><br />If you didn't have your local branch track the remote branch, you could still move changes from one to another, but it becomes more of a manual process. &nbsp;Hey, guess what? &nbsp;I can easily demonstrate all this in action! &nbsp;First, type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-3ege6kBKSEA/UdhLHpCsbRI/AAAAAAAACQk/6WzH1n1HS1U/s1600/status_with_local_change.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-3ege6kBKSEA/UdhLHpCsbRI/AAAAAAAACQk/6WzH1n1HS1U/s1600/status_with_local_change.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 15</td></tr></tbody></table><br />That deleteme.txt ignoring change you made in your local master branch is not yet on Github! &nbsp;You have one commit that Github's (the origin) remote master branch (denoted as origin/master) does not yet have.<br /><br /><i><span style="font-size: x-small;">Don't do this now, but if you don't want to make changes directly in your local master branch, you can create a new local branch, perhaps named "testing" by typing "git branch testing". &nbsp;Then you can switch to that branch by typing "git checkout testing". &nbsp;Then make whatever changes you want, stage and commit them, then switch back to the master branch with "git checkout master". &nbsp;You could also create and switch to a new local branch in one command, "git checkout -b testing".</span></i><br /><span id="pushing-to-the-remote-repository"></span><br /><h4>Pushing to the Remote Repository</h4><br />Let's put your change on Github, then we'll make a change directly on Github and pull it. &nbsp;Git's push command, if you don't provide arguments, will just push all the changes in your local branches to the remote branches they track. &nbsp;This can be dangerous, if you have commits in another local branch and you're not quite ready to push those out also. &nbsp;(I one time accidentally erased the last week of changes in New York Magazine's main repository doing this. &nbsp;We did manage to recover them, but, don't ask.) &nbsp;It's better to be explicit. &nbsp;Type:<br /><br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git push origin master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-tb9Gsi5BpAs/UdhPzn0SGEI/AAAAAAAACQ0/Ff3L2NeBr14/s1600/git_push.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-tb9Gsi5BpAs/UdhPzn0SGEI/AAAAAAAACQ0/Ff3L2NeBr14/s1600/git_push.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 16</td></tr></tbody></table><br />You don't really need to concern yourself with the details of how Git does the upload. &nbsp;But as for the command you just typed, git push lets you specify the "remote" that you're pushing to, and the branch. &nbsp;By specifying the branch, you tell git to take that particular branch ("master", in this case) and update the remote branch, on the origin (your Github potayto repository), with the same name (it will create a new remote "master" branch if it doesn't exist). &nbsp;If you didn't specify "master", it will try to push the changes in all your branches to branches of the same names on the origin (if they exist there. &nbsp;It won't create new remote branches in this case).<br /><br />Anyway, if you type "git status" again, you'll see your branch now matches the remote repository's copy of it. &nbsp;I'd show you, but I can only do so many screen captures, okay? &nbsp;Also what you can do is type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log origin/master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-wI7M9g94Sns/UdhYof5_50I/AAAAAAAACRE/1KDPhNEqo9o/s1600/git_remote_log.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-wI7M9g94Sns/UdhYof5_50I/AAAAAAAACRE/1KDPhNEqo9o/s1600/git_remote_log.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 17</td></tr></tbody></table><br />This is the syntax to see a log of the commits in the master branch on your "origin" remote. &nbsp;You can see the change is there. &nbsp;You can also see this list of commits by logging into Github, viewing your Potayto repository, and clicking on this link:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-S_cHhVyDruk/UdhboTc5y9I/AAAAAAAACRU/TU2h36sfAfk/s1600/commit_history_link.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="363" src="http://4.bp.blogspot.com/-S_cHhVyDruk/UdhboTc5y9I/AAAAAAAACRU/TU2h36sfAfk/s400/commit_history_link.jpg" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 18</td></tr></tbody></table><span id="pulling-changes-from-the-remote-repository"></span><br /><h4>Pulling Changes from the Remote Repository</h4><br />While we're browsing the Github interface, let's use it to create a change that you can fetch (or pull). &nbsp;This will emulate someone else accessing the remote repository and making a change. &nbsp;If you want your local copy of the repository to reflect what's stored in the remote repository, you need to keep yours up to date by intermittently fetching new changes. &nbsp;First, let's create a README.md file which Github will automatically use to describe your project. &nbsp;Github provides a button labeled "Add a README" for this, but let's do it the more generic way. &nbsp;Click the encircled "Add a file" button:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-XxQmqWGH01M/UdhxflvTl4I/AAAAAAAACRk/oO3egbykKlY/s1600/add_new_file_link.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="362" src="http://2.bp.blogspot.com/-XxQmqWGH01M/UdhxflvTl4I/AAAAAAAACRk/oO3egbykKlY/s400/add_new_file_link.jpg" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 19</td></tr></tbody></table>Now type "README.md" for the name and a description that makes sense to you.<br /><br /><span style="font-size: x-small;"><i>The "md" in the filename stands for "Markdown", which is a "markup language" that lets you augment your text with different things just like HTML does. &nbsp;If you want to learn how pretty you can make your README file, you can learn more about Markdown&nbsp;<a href="http://daringfireball.net/projects/markdown/basics">here</a>, but just realize Github uses a&nbsp;<a href="https://help.github.com/articles/github-flavored-markdown">slightly modified version of Markdown</a>.</i></span><br /><br />Click the "Commit New File" button:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-RC19QZiM0ec/Udh3rugVZlI/AAAAAAAACR0/hx3NwMI8eHA/s1600/creating_readme.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="640" src="http://2.bp.blogspot.com/-RC19QZiM0ec/Udh3rugVZlI/AAAAAAAACR0/hx3NwMI8eHA/s640/creating_readme.jpg" width="616" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 20</td></tr></tbody></table>You'll see your project described as desired. &nbsp;Go back to your terminal window and type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-LeGJu8Vs2H8/Udc02oIosNI/AAAAAAAACNw/asMPQVB83kw/s1600/first_git_status.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-LeGJu8Vs2H8/Udc02oIosNI/AAAAAAAACNw/asMPQVB83kw/s1600/first_git_status.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 21</td></tr></tbody></table><br />Wait a sec... Why's it saying that your local branch is up to date? &nbsp;It's because the git "status" command does not do any network communication. &nbsp;Even typing "git log origin/master" won't show the change. &nbsp;Only Git's "push", "pull", and "fetch" does anything over the network. &nbsp;Let's talk about "fetch", as "pull" is just a shortcut of functionality that "fetch" can do.<br /><br />When you track a remote branch, you do get a copy of that remote branch in your local repository. &nbsp;However, aside from those three aforementioned commands that talk over the network, git treats these remote branches just like any other branches. &nbsp;You can even have one local branch track another local branch. &nbsp;(Probably won't need to do that.)<br /><br />So, how do we update our local copies of the remote branches? &nbsp;"git fetch" will update all the local copies of the remote branches listed in your .git/config file. &nbsp;Here, I'll start adding more shadows to my screenshots, in case you actually aren't as excited about all this niftiness as I am. &nbsp;Please type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git fetch</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-mUVI5GkB5mM/Udh---HtqfI/AAAAAAAACSE/VOfYi1mQfrY/s1600/Screen+Shot+2013-07-06+at+4.32.09+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-mUVI5GkB5mM/Udh---HtqfI/AAAAAAAACSE/VOfYi1mQfrY/s1600/Screen+Shot+2013-07-06+at+4.32.09+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 22</td></tr></tbody></table><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-m9V2IfnpJWA/UdiC2T6a-II/AAAAAAAACSc/0ehVcoKyJ0U/s1600/Screen+Shot+2013-07-06+at+4.44.41+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-m9V2IfnpJWA/UdiC2T6a-II/AAAAAAAACSc/0ehVcoKyJ0U/s1600/Screen+Shot+2013-07-06+at+4.44.41+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 23</td></tr></tbody></table>Now, you'll notice there's still no difference if you type "git log", but let's type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log origin/master</span></blockquote><div class="separator" style="clear: both; text-align: center;"></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-fEztG9Nw8XY/UdiC2Q7-52I/AAAAAAAACSY/Lo0PIR0eYZw/s1600/Screen+Shot+2013-07-06+at+4.48.58+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto; text-align: center;"><img border="0" src="http://2.bp.blogspot.com/-fEztG9Nw8XY/UdiC2Q7-52I/AAAAAAAACSY/Lo0PIR0eYZw/s1600/Screen+Shot+2013-07-06+at+4.48.58+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 24</td></tr></tbody></table>Now you see the remote change. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote>&nbsp;See, this is more like it, but what does "fast-forwarded" mean? &nbsp;Fast-forwarding is a version of "merging". &nbsp;It means there's no potential conflict. &nbsp;It means you took all the changes in a branch, such as the remote master branch, and made changes from there, while no new changes were made in the remote branch. &nbsp;I'll explain more later, in the section on "rebasing", but for now, we're going to pull these changes in. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git merge origin/master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-enl2HZO4-Kc/Udiklq6JkNI/AAAAAAAACSs/0aQRggGW7m8/s1600/Screen+Shot+2013-07-06+at+7.12.53+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-enl2HZO4-Kc/Udiklq6JkNI/AAAAAAAACSs/0aQRggGW7m8/s1600/Screen+Shot+2013-07-06+at+7.12.53+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 25</td></tr></tbody></table>This tells you there was one file inserted. &nbsp;Now if you typed "git log", you'd see that you brought the change first from the master branch on your Github repository to your origin/master branch, and then from there to your local master branch. &nbsp;You could even have absolute proof of the change by looking in your current directory:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-rBJJRAMM-Dc/UdjBHUFvp_I/AAAAAAAACTM/4rERA1Ow0Uo/s1600/Screen+Shot+2013-07-06+at+9.14.49+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-rBJJRAMM-Dc/UdjBHUFvp_I/AAAAAAAACTM/4rERA1Ow0Uo/s1600/Screen+Shot+2013-07-06+at+9.14.49+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 26</td></tr></tbody></table>See the README.md file? &nbsp;Of course, there is a short cut. &nbsp;It's too late, but you could have done everything in one fell swoop by typing:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git pull origin master</span></blockquote>That would have not only fetched the commits from the remote repository, but would also have done the merge. &nbsp;And if you want to pull all of the branches from all the remote repositories that your .git/config file lists, you can just type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git pull</span></blockquote>You can be as trigger happy as you want with that for now, but when you start dealing with more than one branch, you might update some branches you weren't yet ready to update.<br /><br /><span id="merges-and-conflicts"></span><br /><h4>Merges and Conflicts</h4><br />Now for the purposes of learning about merges, we're going to undo that last merge. &nbsp;Very carefully, type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git reset HEAD~1 --hard</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-WxBsum_MTkQ/Udi4_L2Z5SI/AAAAAAAACS8/MkghUlqFvfg/s1600/Screen+Shot+2013-07-06+at+8.39.39+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-WxBsum_MTkQ/Udi4_L2Z5SI/AAAAAAAACS8/MkghUlqFvfg/s1600/Screen+Shot+2013-07-06+at+8.39.39+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 27</td></tr></tbody></table><span style="font-size: x-small;"><i>The "HEAD~1" means "the 1st commit before the latest commit", with the latest commit referred to as the "HEAD" of the branch (currently master). &nbsp;By resetting "hard", you're actually permanently erasing the last commit from your local master branch. &nbsp;As far as Git's concerned, the last link in the master branch's "chain" now is the commit that was previously second to last. &nbsp;Don't get in the habit of this. &nbsp;It's just for the purpose of this tutorial.</i></span><br /><br />Don't worry -- we don't have to mess with remote repositories for a while. &nbsp;Your new README.md file is also safely committed to your local repository's cached version of the remote master branch, "origin/master". &nbsp;You <b>could</b> type "git merge origin/master" to re-merge your changes, but don't do it right now.<br /><br />Let's say someone else added that README.md, and you were unaware. &nbsp;You start to create a README.md in &nbsp;your local repository, with the intention of pushing it to the remote repository later. &nbsp; Because we undid our change, there is no longer a README.md file in your current directory.<br />Normally you'd use a text editor, but for now, type this to create a new README.md file:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">echo A test repository for learning git &gt; README.md</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-ddE5Le_OrAs/UdjCHuNRIkI/AAAAAAAACTY/6ZGReoqZeHg/s1600/Screen+Shot+2013-07-06+at+9.18.48+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-ddE5Le_OrAs/UdjCHuNRIkI/AAAAAAAACTY/6ZGReoqZeHg/s1600/Screen+Shot+2013-07-06+at+9.18.48+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 28</td></tr></tbody></table>I used the cat command (For Windows, it'd be "type") to display the contents of the simple file we created. &nbsp;Let's stage and commit the thing. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git add README.md</span></blockquote>then type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -m "Created a simple readme file"</span></blockquote>and finally:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-DnT7X1I-I7k/UdjEU1f8BRI/AAAAAAAACTo/OQIonkPoMC8/s1600/Screen+Shot+2013-07-06+at+9.28.34+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-DnT7X1I-I7k/UdjEU1f8BRI/AAAAAAAACTo/OQIonkPoMC8/s1600/Screen+Shot+2013-07-06+at+9.28.34+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 29</td></tr></tbody></table>Now we have two versions of a README.md file committed. &nbsp;You can see that your origin/master branch is one commit in one direction, and your master branch is one commit in the other direction. &nbsp;What will happen when I try to update master from origin/master? &nbsp;Let's see! &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git merge origin/master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-aIcCmlQV4pU/UdjFEqQV0WI/AAAAAAAACT0/G78QTsYQWNU/s1600/Screen+Shot+2013-07-06+at+9.31.46+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-aIcCmlQV4pU/UdjFEqQV0WI/AAAAAAAACT0/G78QTsYQWNU/s1600/Screen+Shot+2013-07-06+at+9.31.46+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 30</td></tr></tbody></table>Just as you might think, git is flummoxed. &nbsp;This is essentially Git saying "<b>You</b> fix it." &nbsp;Let's see what state we're in. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-YV9dsoYGYXM/UdjG1Cg7XqI/AAAAAAAACUE/tLJiUtLomIg/s1600/Screen+Shot+2013-07-06+at+9.37.36+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-YV9dsoYGYXM/UdjG1Cg7XqI/AAAAAAAACUE/tLJiUtLomIg/s1600/Screen+Shot+2013-07-06+at+9.37.36+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 31</td></tr></tbody></table><br />Can't be any clearer, except for one detail. &nbsp;Git <b>is</b> telling us to type "git add/rm whatever" to "mark resolution. &nbsp;That means, in order to fix this, you could take one of two routes. &nbsp;<b>DON'T DO THIS!</b> ... You could go into README.md, fix it up, then stage it with git add. &nbsp;Edit the README.md file. &nbsp;I'll use vim, but you use whatever editor you want:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-O7u-QX61kng/UdjIC22rMmI/AAAAAAAACUU/cOH3prz8HGc/s1600/Screen+Shot+2013-07-06+at+9.44.10+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-O7u-QX61kng/UdjIC22rMmI/AAAAAAAACUU/cOH3prz8HGc/s1600/Screen+Shot+2013-07-06+at+9.44.10+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 32</td></tr></tbody></table>You can see that the two versions are marked very clearly. &nbsp;HEAD represents "the current local branch you're on", which is master. &nbsp;If you review all the times you've typed "git status", it's told you that you're on branch "master". &nbsp;And we know "origin/master" is our local copy of the remote repository's master branch. &nbsp;I'm going to remove the scary divider lines (e.g. &lt;&lt;&lt;&lt;, ====,&gt;&gt;&gt;&gt;) and replace those two versions of project descriptions with a new one:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-XuWNUoo5nYw/UdjJl7rPL6I/AAAAAAAACUk/jUve8TcHeNc/s1600/Screen+Shot+2013-07-06+at+9.50.57+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-XuWNUoo5nYw/UdjJl7rPL6I/AAAAAAAACUk/jUve8TcHeNc/s1600/Screen+Shot+2013-07-06+at+9.50.57+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 33</td></tr></tbody></table>If you ignored my warning and you're doing this, don't save! &nbsp;Just exit out! &nbsp;But if you were doing this, you could save and exit, then "git add" the file, then "git commit", to stage and commit. &nbsp;It's actually better in some ways, because you're able to rethink each change, and perhaps reword something like I was about to do for this README file.<br /><br />However, the reason I told you not to do this is because it's the hard way, especially for complicated conflicts. &nbsp;Instead, while still in your project directory, having just experienced a failed merge command, type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git mergetool</span></blockquote><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-7B8As8i_h7Q/UdjO3nC5m4I/AAAAAAAACVM/53koWgLA9gc/s1600/start_mergetool.tiff" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-7B8As8i_h7Q/UdjO3nC5m4I/AAAAAAAACVM/53koWgLA9gc/s1600/start_mergetool.tiff" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 34</td></tr></tbody></table><br />Mergetool will guide you through each conflicted file, letting you choose which version of each conflicted line you'd like to use for the committed file. &nbsp;You can see, by default, it will use "opendiff". &nbsp;Press enter to see what "opendiff" looks like:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-IJ5kjmPSY1w/UdjVHDdwrHI/AAAAAAAACVs/kBZQ9mtax2k/s1600/Screen+Shot+2013-07-06+at+10.17.30+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="304" src="http://4.bp.blogspot.com/-IJ5kjmPSY1w/UdjVHDdwrHI/AAAAAAAACVs/kBZQ9mtax2k/s640/Screen+Shot+2013-07-06+at+10.17.30+PM.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 35</td></tr></tbody></table><br />If this were more than one line, you'd be able to say "use the left version for this conflict line". &nbsp;Or "use the right version for this line". &nbsp;Or "I don't want to use either line." &nbsp;In this case, we only have one conflicted line to choose from, so make it count! &nbsp;The one conflicted line is selected. &nbsp;Click on the "Actions" pull down menu and choose "Choose right". &nbsp;You'll see nothing changed. &nbsp;That was because that arrow in the middle was already pointing to the right. &nbsp;Try selecting "Choose left", then "Choose right" again. &nbsp;You'll see what I mean. &nbsp;Opendiff doesn't give you the opportunity to put in your own custom line. &nbsp;You can do that later if you wish.<br /><br />At the pull down menu at the top of the screen, select "File" then "Save Merge":<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-SU2CPFb4xAE/UdjXnzY_o5I/AAAAAAAACWE/WsVX1MSY9_U/s1600/Screen+Shot+2013-07-06+at+10.45.13+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-SU2CPFb4xAE/UdjXnzY_o5I/AAAAAAAACWE/WsVX1MSY9_U/s1600/Screen+Shot+2013-07-06+at+10.45.13+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 36</td></tr></tbody></table><br />Go back to the menu and select "Quit FileMerge". &nbsp;Now again type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><br /><br /><div class="separator" style="clear: both; text-align: center;"></div><br />Select the line then<br />Let's stage the new version of the readme file. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git add README.md</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-kjDdMxAYG0I/UdjahPzDPQI/AAAAAAAACWU/QDXqP3lNAUo/s1600/Screen+Shot+2013-07-06+at+11.03.11+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-kjDdMxAYG0I/UdjahPzDPQI/AAAAAAAACWU/QDXqP3lNAUo/s1600/Screen+Shot+2013-07-06+at+11.03.11+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 37</td></tr></tbody></table>All set to commit changes, just like if you manually modified and staged (with "git add") the files yourself. &nbsp;Now type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -m "Merged remote version of readme with local version."</span></blockquote>and then:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git status</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-sNyrCkquF2Q/UdjdQN9o4iI/AAAAAAAACWk/Kg-THQWJs80/s1600/Screen+Shot+2013-07-06+at+11.14.06+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-sNyrCkquF2Q/UdjdQN9o4iI/AAAAAAAACWk/Kg-THQWJs80/s1600/Screen+Shot+2013-07-06+at+11.14.06+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 38</td></tr></tbody></table>Before we go on, if you noticed, there's a lingering "README.md.orig" file. &nbsp;That's just a backup in case the merged file you came up with looks horrible. &nbsp;However, it's a pain to deal with these "orig" files. &nbsp;For this time, you can move the file somewhere, or just delete it, but, check out&nbsp;<a href="http://travisjeffery.com/b/2011/12/keeping-your-git-repo-clean-of-orig-files/">this page</a>&nbsp;on many strategies you can leverage to deal with those files.<br /><br />Back to the merge. &nbsp;Look! &nbsp;Your branch is "ahead" of "origin/master" by 2 commits. &nbsp;Let's see what those commits are. &nbsp;To show just the last two commits, type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log -n 2</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-LTVQuJ130b0/UdjfA7CZOLI/AAAAAAAACW0/ZWPJk-uwLh0/s1600/Screen+Shot+2013-07-06+at+11.22.01+PM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-LTVQuJ130b0/UdjfA7CZOLI/AAAAAAAACW0/ZWPJk-uwLh0/s1600/Screen+Shot+2013-07-06+at+11.22.01+PM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 39</td></tr></tbody></table>The earlier commit on the bottom is the one you did before, to create your local version of the readme file. &nbsp;The top commit is the "merge commit", that Git uses to identify where two branches were merged. &nbsp;Now review what state "origin/master" is in with "git log origin/master". &nbsp;We want our merged version of the readme to Github. &nbsp;Yes, we're back on the internet! &nbsp;Let's push our changes to origin/master and see what happens. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git push origin master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-X4rVH9EsNmw/UdjzCBbH97I/AAAAAAAACXE/Y15iNl8mBEE/s1600/Screen+Shot+2013-07-07+at+12.47.07+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-X4rVH9EsNmw/UdjzCBbH97I/AAAAAAAACXE/Y15iNl8mBEE/s1600/Screen+Shot+2013-07-07+at+12.47.07+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 40</td></tr></tbody></table>Now, just to be sure, we're not going to look at the "local version" of the remote branch. &nbsp;Let's go right to Github to see what happened. &nbsp;View the commits in your repository:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-GigTtBK5FgQ/Udj6QWZMiNI/AAAAAAAACXU/3zLLaigucEU/s1600/Screen+Shot+2013-07-07+at+12.57.07+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="490" src="http://3.bp.blogspot.com/-GigTtBK5FgQ/Udj6QWZMiNI/AAAAAAAACXU/3zLLaigucEU/s640/Screen+Shot+2013-07-07+at+12.57.07+AM.png" width="640" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 41</td></tr></tbody></table>What might not make sense here, is that you have first the Github-side readme commit, then your local readme commit, <b>then</b> the merge. &nbsp;It doesn't make sense for all of these commits to happen in sequence, since the first two are conflicting. &nbsp;What happens is that your local readme file commit is logged as a commit on a separate branch that is merged in. &nbsp;Let's graphically demonstrate that by clicking on the "Network" button on the right (circled in red).<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-L4dan-Hk41o/UdkIBjCn4pI/AAAAAAAACXk/nEZob6EoY9M/s1600/Screen+Shot+2013-07-07+at+2.16.55+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-L4dan-Hk41o/UdkIBjCn4pI/AAAAAAAACXk/nEZob6EoY9M/s1600/Screen+Shot+2013-07-07+at+2.16.55+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 42</td></tr></tbody></table>Each dot in this diagram represents a commit. &nbsp;Later commits are on the right. &nbsp;The one that looks like it was committed to a separate branch (your local master branch) and then <b>merged</b> in is the commit of your local version of the readme file. &nbsp;Hover over this dot and see for yourself.<br /><br /><i><span style="font-size: x-small;">It's good to pull in remote changes not too infrequently, to minimize the complexity of conflicts.</span></i><br /><br /><span id="rebasing"></span><br /><h4>Rebasing</h4><br />This is as advanced as this tutorial is going to get, and you're in the homestretch! &nbsp;Rebasing is meant to give you that clean, fresh feeling when committing your changes. &nbsp;With it, you can shape your commits how you prefer before merging them to another branch. &nbsp;But wait, you might think... You can already do that when you're staging your files. &nbsp;You can stage and unstage files repeatedly, getting a commit exactly how you want. &nbsp;There are two main things that rebasing lets you do in addition to that.<br /><br />Let's say you were working on branch A and you created branch B. &nbsp;<b>Branch B is nothing more than a series of changes made to a specific version of branch A</b>&nbsp;(starting with a specific commit in branch A). &nbsp;Let's say you were able to take those changes and reapply them to the last commit in branch A. &nbsp;It's as though you checked out branch A and you made the same changes. &nbsp;Read this paragraph as many times as you need to before you move on.<br /><br />Remember when I mentioned about fast-forward commits? &nbsp;When you viewed the commit history on Github, did you like seeing commits on other branches being merged in? &nbsp;Or would you have preferred one commit after another? &nbsp;Most prefer the latter. &nbsp;Merging can get quite messy in a worst-case scenario, but even if it's not so bad, it's not preferable. &nbsp;You can use rebasing to allow your merges to be "fast-forward", so when you merge your changes into another branch, there's no "merge commit". &nbsp;Your changes are simply added as the next commits in the target branch, and the new latest commit of that branch is your last change.<br /><br />Let's demonstrate before I talk about the next benefit. &nbsp;I explained how to create and switch to local branches at the end of the "Branches" section. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git branch testing</span></blockquote>We're still in the master branch. &nbsp;Now let's make another change to that awful readme file again. &nbsp;Load up your editor and add the line: "Inspired by the Gershwin brothers" then save:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-YS1Dxq9974M/UdkVez6PaLI/AAAAAAAACX0/GYTQ37vzhU0/s1600/Screen+Shot+2013-07-07+at+3.14.35+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-YS1Dxq9974M/UdkVez6PaLI/AAAAAAAACX0/GYTQ37vzhU0/s1600/Screen+Shot+2013-07-07+at+3.14.35+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 43</td></tr></tbody></table>If you type "git status", you'll see the only modification is to the readme file. &nbsp;A shortcut I didn't tell you about, to stage and commit all modified files at the same time,&nbsp;<b>if all the modified files have already been staged once&nbsp;</b>(they're not "untracked"), is by using git commit's "a" flag:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -am "Added something to the readme file"</span></blockquote>then view the log with:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log -n 2</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-MqVAyw4GSWw/UdkYo_Ce7SI/AAAAAAAACYE/fJ8h-U2oWg8/s1600/Screen+Shot+2013-07-07+at+3.28.19+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-MqVAyw4GSWw/UdkYo_Ce7SI/AAAAAAAACYE/fJ8h-U2oWg8/s1600/Screen+Shot+2013-07-07+at+3.28.19+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 44</td></tr></tbody></table>There's our change, right after our merge commit. &nbsp;We're not going to make the mistake of adding any more messy merge commits. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git checkout testing</span></blockquote>and then view the README.md file:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-LzWcnw8YmPk/UdkcuAdYvBI/AAAAAAAACYU/jIFFSoZd34s/s1600/Screen+Shot+2013-07-07+at+3.45.43+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-LzWcnw8YmPk/UdkcuAdYvBI/AAAAAAAACYU/jIFFSoZd34s/s1600/Screen+Shot+2013-07-07+at+3.45.43+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 45</td></tr></tbody></table>You see that your modification is no longer there. &nbsp;I'd have you modify the readme file again, but I think I'm done explaining conflict resolution. &nbsp;If you did modify readme, and then you wanted to reapply your changes over the latest version of the master branch, you'd have another bloody conflict to resolve. &nbsp;Let's just create a change in our source code.<br /><br />Edit the file "src/main/scala/scottdanzig/potayto/Potayto.scala" and add the printing of "Ding!" as shown. &nbsp;Please, just humor me...<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-kkT76JfuHP4/UdkefuJF1NI/AAAAAAAACYk/r6s3HQ0DeQ8/s1600/Screen+Shot+2013-07-07+at+3.53.08+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-kkT76JfuHP4/UdkefuJF1NI/AAAAAAAACYk/r6s3HQ0DeQ8/s1600/Screen+Shot+2013-07-07+at+3.53.08+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 46</td></tr></tbody></table>Now stage and commit:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -am "Added the printing of Ding"</span></blockquote>then show the last two changes for both the current "testing" branch and the "master" branch with:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git log -n 2 &lt;branch&gt;</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-X4Q1VkuxUBg/UdkgDlZz3YI/AAAAAAAACY0/a6D2UeSUiBU/s1600/Screen+Shot+2013-07-07+at+3.59.56+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-X4Q1VkuxUBg/UdkgDlZz3YI/AAAAAAAACY0/a6D2UeSUiBU/s1600/Screen+Shot+2013-07-07+at+3.59.56+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 47</td></tr></tbody></table>There be a storm a-brewin'! &nbsp;Hang in there! &nbsp;If you merged the testing branch into master now, you'd again see your change added to the master branch, followed by a merge commit. &nbsp;Wouldn't it be simple if we can recreate testing from the current version of master, then automatically make your change again for you? &nbsp;Then you'd only be adding your "Added the printing of Ding" commit. &nbsp;You can do just that right now. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git rebase master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-R_pBH8Rs8wM/UdkhikxfltI/AAAAAAAACZE/Y0YlGVQiL_Q/s1600/Screen+Shot+2013-07-07+at+4.05.44+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-R_pBH8Rs8wM/UdkhikxfltI/AAAAAAAACZE/Y0YlGVQiL_Q/s1600/Screen+Shot+2013-07-07+at+4.05.44+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 48</td></tr></tbody></table>Git talks of "reapplying commits" as "replaying work". &nbsp;How does it know which commits in your current branch to reapply/replay? &nbsp;It traverses down the branch, starting with the most recent commit, and finds the first commit that is in the master branch. &nbsp;Now let's see the log:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-5d-vwNK6JHc/UdkiPrSbl9I/AAAAAAAACZM/Tp1JnunvJWc/s1600/Screen+Shot+2013-07-07+at+4.09.11+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-5d-vwNK6JHc/UdkiPrSbl9I/AAAAAAAACZM/Tp1JnunvJWc/s1600/Screen+Shot+2013-07-07+at+4.09.11+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 49</td></tr></tbody></table>See? &nbsp;It's exactly what I described. &nbsp;It's as though you waited for that last change to master to be made before branching. &nbsp;Now see how easy it is to merge in your changes by switching to the master branch and doing the merge:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-ktqVWFmMLVU/UdkjlHYCS3I/AAAAAAAACZc/-jzh9FPUtvc/s1600/Screen+Shot+2013-07-07+at+4.14.57+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-ktqVWFmMLVU/UdkjlHYCS3I/AAAAAAAACZc/-jzh9FPUtvc/s1600/Screen+Shot+2013-07-07+at+4.14.57+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 50</td></tr></tbody></table>A fast-forward merge is <b>so</b> easy.<br /><br />I mentioned there are <b>two</b> things rebasing lets you do that you can't do just with staging. &nbsp;There's this notion of "interactive rebasing" that I think is the coolest part of git. &nbsp;This is the last part of the tutorial where you have to do anything, so this is the homestretch of the homestretch. &nbsp;Now we're going back to our testing branch (currently the same as master) and create two new files, A and B. &nbsp;I'm going to keep this simple. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git checkout testing</span></blockquote>then:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">echo test &gt; A</span></blockquote>and stage and commit that change. &nbsp;File "A" is new/untracked, so you can't use the "-am" shortcut:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git add A</span></blockquote>and then:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git commit -m "Added A"</span>&nbsp;</blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-3-DPsSt_2Tw/Udkm0HelmHI/AAAAAAAACZs/F3vmFAn4_m4/s1600/Screen+Shot+2013-07-07+at+4.28.37+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-3-DPsSt_2Tw/Udkm0HelmHI/AAAAAAAACZs/F3vmFAn4_m4/s1600/Screen+Shot+2013-07-07+at+4.28.37+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 51</td></tr></tbody></table>Now create another file, B:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">echo test &gt; B</span></blockquote>and stage then commit as well:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git add B</span><span style="font-family: Courier New, Courier, monospace;">git commit -m "Added B"</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-YLVJJzhcM3w/UdknaE61d0I/AAAAAAAACZ0/yKjwUmsD5YY/s1600/Screen+Shot+2013-07-07+at+4.31.10+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-YLVJJzhcM3w/UdknaE61d0I/AAAAAAAACZ0/yKjwUmsD5YY/s1600/Screen+Shot+2013-07-07+at+4.31.10+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 52</td></tr></tbody></table>You'll see both of those commits in the log:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-X-VXj4-yaho/UdkoBLdTa-I/AAAAAAAACaA/ILcizN4hgtE/s1600/Screen+Shot+2013-07-07+at+4.33.56+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-X-VXj4-yaho/UdkoBLdTa-I/AAAAAAAACaA/ILcizN4hgtE/s1600/Screen+Shot+2013-07-07+at+4.33.56+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 53</td></tr></tbody></table>Okay, we're all set to show off interactive rebasing. &nbsp;We're going to combine those two commits you just did into one commit. &nbsp;You have two options:<br /><br /><ul><li>You can do this in the same branch, if you just want to reorganize a branch while you're working with it.</li><li>You can also combine commits when you're rebasing (reapplying/replaying) them onto another branch.</li></ul><br />If you don't think this is the bees knees, you're nuts. &nbsp;We're going to do the rebasing the second way, while rebasing onto master. &nbsp;The latest change on master is contained in the testing branch, so rebasing just to avoid merge commits would be unnecessary. &nbsp;Merging testing into master would be a fast-forward merge. &nbsp;However, we're also going to use this opportunity to combine the two commits. &nbsp;Rebasing can be multi-purpose that way. &nbsp;Type:<br /><blockquote class="tr_bq"><span style="font-family: Courier New, Courier, monospace;">git rebase -i master</span></blockquote><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-dqfBsbWMPBI/Udkr1NGnQ7I/AAAAAAAACao/blwlQBEYS4s/s1600/Screen+Shot+2013-07-07+at+4.50.10+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://2.bp.blogspot.com/-dqfBsbWMPBI/Udkr1NGnQ7I/AAAAAAAACao/blwlQBEYS4s/s1600/Screen+Shot+2013-07-07+at+4.50.10+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 54</td></tr></tbody></table>Git might scare you with a vim editor window like this. &nbsp;You see those two "pick" lines at the top? This &nbsp;is a list of the commits that are going to be reapplied, with the oldest change on top. &nbsp;If you change an instance of the word "pick" to "squash", the commit listed on that line will get combined/melded into the older commit above it. &nbsp;You need the oldest commit you want to reapply to be a "pick". &nbsp;You can use "p" and "s" instead of "pick" and "squash" by the way. &nbsp;If you want, you can even remove some commits from this list all together, but be careful. &nbsp;That effectively removes all record of that commit from the current branch. &nbsp;Oh look! &nbsp;It even warns you in ominous CAPITAL LETTERS.<br /><br />Let's change the second "pick" to a "squash". &nbsp;It's possible to change your default editor from "vim" if you want, but if you prefer vim like me or just haven't got around to it yet, just heed my instructions:<br />Use the arrow keys to move the cursor to the "p" of the second "pick".<br /><br /><ol><li>Type "cw" to change the word.</li><li>Type "s" then press the escape button.</li><li>Type ":x" to exit and save.</li></ol><br />Now you should see a screen allowing you to create the new commit message:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://4.bp.blogspot.com/-LsvsRymaDT4/UdkvbYDTb1I/AAAAAAAACa4/eAFFIqHpKlg/s1600/Screen+Shot+2013-07-07+at+5.04.41+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://4.bp.blogspot.com/-LsvsRymaDT4/UdkvbYDTb1I/AAAAAAAACa4/eAFFIqHpKlg/s1600/Screen+Shot+2013-07-07+at+5.04.41+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 55</td></tr></tbody></table>This gives you the opportunity to write the new description, perhaps multi-lined for the combined commit. &nbsp;By default, Git will just put all the combined commit messages one after the other. &nbsp;If you want, you can accept that and just type ":x" to exit and save. &nbsp;Or, you can use vim to modify the file to your liking. &nbsp;If you want to give it a shot, just press "i" to go into insert mode, then use the arrows to move around and backspace to delete. &nbsp;When you're done, press the escape key then type ":x". &nbsp;Here's my modified file:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-2K5FBXKS_uM/UdkxDMZXMDI/AAAAAAAACbI/wT-2IvHuXmU/s1600/Screen+Shot+2013-07-07+at+5.12.06+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-2K5FBXKS_uM/UdkxDMZXMDI/AAAAAAAACbI/wT-2IvHuXmU/s1600/Screen+Shot+2013-07-07+at+5.12.06+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 56</td></tr></tbody></table>I could have ignored the lines starting with #, but I got rid of some of them for clarity. &nbsp;Here's what the log looks like after I saved and exited:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-5D-I2CJ00dI/UdkxvdgsvGI/AAAAAAAACbQ/NaQ0n1YyM6A/s1600/Screen+Shot+2013-07-07+at+5.14.31+AM.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="http://3.bp.blogspot.com/-5D-I2CJ00dI/UdkxvdgsvGI/AAAAAAAACbQ/NaQ0n1YyM6A/s1600/Screen+Shot+2013-07-07+at+5.14.31+AM.png" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 57</td></tr></tbody></table>See the one big commit? &nbsp;That "printing of Ding" commit afterward is the latest commit currently in the master branch, so merging the testing branch into master would be a fast-forward merge. &nbsp;I'd demonstrate that, but I'd rather avoid redundancy and finish the tutorial.<br /><br /><span id="pull-requests"></span><br /><h4>Pull Requests</h4><br />Commits are often grouped into "feature branches", representing all the changes needed for a branch. &nbsp;How projects with designated maintainer(s) often operate is as follows:<br /><br /><ul><li>You push your "feature branch" to a remote repository, often your fork of the main repository.</li><li>You create a "pull request" on Github for that branch, which tells the project maintainer that you want your branch merged into the master branch.</li><li>If the branch is recent enough where it's spawned from the most recent commit on the project's master branch, or it can be rebased onto master without any conflicts, the maintainer can easily merge in your changes.</li><li>If there are conflicts, then it's up to the maintainer to do the merge, or to reject the pull request and let you rebase and deconflict the commits in your branch yourself.</li></ul><br /><h3></h3><span id="new-york-magazine-development-environment"></span><br /><h3>New York Magazine Development Environment</h3><br />At New York Magazine, where I work, we generally have 4 main branches of each project entitled dev, qa, stg, prod. &nbsp;We have software called <a href="http://jenkins-ci.org/">Jenkins</a>&nbsp;that monitors each branch, and when any change is made, the project is redeployed to a computer/server dedicated to that environment. &nbsp;</div><div><ul><li><b>dev</b>&nbsp;branch - While developers first test their code on their own computers, eventually they need to test changes on a server with shared resources. &nbsp;This often exposes a bunch of integration issues so often a change requires multiple commits (multiple attempts to get it right) before the change is complete. &nbsp;It's a necessary evil that developers simultaneously make changes in this environment for their own features. Hopefully, someone else's changes don't affect testing of your own changes.</li><li><b>qa</b>&nbsp;branch - This is branch is for QA (quality assurance) testing to be done on a new change. &nbsp;The branch is cleaner, only having completed changes, and, although everything isn't necessarily optimized (maybe you do have debugging information being recorded to the log, for instance), it's much more controlled as opposed to dev.</li><li><b>stg</b>&nbsp;branch - Changes approved by QA go to the "staging" environment. &nbsp;This environment to be fully optimized, as if it were the production environment. &nbsp;There could be more issues that are exposed by testing in a fully optimized environment, but usually not. &nbsp;<span style="font-size: x-small;"><i>This is not to be confused with the much lower-level staging in git, but ultimately, the concept is the same. &nbsp;You're ultimately preparing a set of features that are slated to go public, rather than a bunch of file changes that are about to be committed.</i></span></li><li><b>prod</b>&nbsp;branch - What your clients/customers/users ultimately see is deployed directly from this branch.</li></ul></div><div>To manage the environment-specific configuration, including enabling optimizations and altering logging levels, we use&nbsp;<a href="http://puppetlabs.com/puppet/puppet-enterprise/">Puppet</a>. &nbsp;We also use Git to maintain our internal documentation, written as text files using the Git-variety of Markdown, to allow ease of collaboration and code-friendly formatting. &nbsp;Hosting a project on Github is free unless it's to be private. &nbsp;Most New York Magazine repositories are private.<br /><br />Each commit message at New York Magazine, optimally, should have a "story number". &nbsp;A "story" is a description of a desired modification. &nbsp;If something should be changed in code, someone describes how the change works in a web interface provided by a story-tracking application such as Atlassian's&nbsp;<a href="http://www.atlassian.com/software/jira">JIRA</a>, which we use. &nbsp;A developer can modify the "status" of the story to reflect progress being made toward its resolution.<br /><br />We use something called&nbsp;<a href="http://www.atlassian.com/software/crucible/overview">Crucible</a>&nbsp;for "peer code reviews". &nbsp;This lets a developer send a series of commits out to fellow developers to have a look at. &nbsp;It tracks who has had a change to review your code, and gives them the opportunity to make comments.<br /><br /><br /><span id="my-preferred-workflow-with-git"></span><br /><h3>My Preferred Workflow with Git</h3><br />I'm typically tasked with a modification I must make to a shared project hosted as a Github repository as I described. &nbsp;On Github, I have a separate user, "scottdanzig" for my job-related Github activity, which allows clear separation of my personal projects from what I've done that is New York Magazine property. &nbsp;For my examples, I'll refer to a web application created with Scala and the Play Framework, that provides restaurant listings for your mobile device. &nbsp;Let's say we realized that the listings load very fast, and we can afford to display larger pictures. &nbsp;Here is my preferred workflow:<br /><br /><span id="changing-the-code"></span><br /><h4>Changing the Code</h4><br /><br /><ul><li>First thing I do is change the status of the JIRA story I'm going to work on to "In Progress".</li><li>If I don't yet have the project cloned onto my machine, I'll do that first: <span style="font-family: Courier New, Courier, monospace;">git clone https://github.com/nymag/listings.git</span></li><li>I checkout the dev branch: <span style="font-family: Courier New, Courier, monospace;">git checkout dev</span></li><li>I update my dev branch with the latest from the remote repository: <span style="font-family: Courier New, Courier, monospace;">git pull origin dev</span></li><li>I create and checkout a branch off dev: <span style="font-family: Courier New, Courier, monospace;">git checkout -b larger-pics</span></li><li>I make my modifications and test as much as I can, staging and committing my changes after successfully testing each piece of the new functionality.</li><li>I'll then update my dev branch again, so when I merge back, hopefully it's a fast-forward merge: <span style="font-family: Courier New, Courier, monospace;">git pull origin dev</span></li><li>I'll interactively rebase my larger-pics branch onto my dev branch. &nbsp;This gives me an opportunity to change all my commits to one big commit, to be applied to the latest commit on the dev branch: <span style="font-family: Courier New, Courier, monospace;">git rebase -i dev</span> then I change all "picks" but the top one to a squash. &nbsp;I write one comprehensive commit message detailing my changes so far, making sure to start with the JIRA story number so people can review the motivation behind the change. &nbsp;<span style="font-size: x-small;"><i>It's possible I might want to not combine all my commits yet. &nbsp;If I'm not sure if one of the incremental changes is necessary, I may decide to keep it as a separate commit. &nbsp;This is possible if you leave it as a separate "pick" during the interactive rebasing. &nbsp;Git will give you an opportunity to rewrite the commit description for that commit separately.</i></span></li><li>I checkout the dev branch: <span style="font-family: Courier New, Courier, monospace;">git checkout dev</span></li><li>Then I merge in my one commit: <span style="font-family: Courier New, Courier, monospace;">git merge larger-pics</span></li><li>Then I push it to Github: <span style="font-family: Courier New, Courier, monospace;">git push origin dev</span></li><li>If it complains about it not being a fast-forward merge and rejects my change, I may need to rebase my dev branch onto origin/dev and then try again. &nbsp;We're not going to combine any commits, so it doesn't need to be interactive: &nbsp;<span style="font-family: Courier New, Courier, monospace;">git rebase origin/dev</span> then again: <span style="font-family: Courier New, Courier, monospace;">git push origin dev</span></li><li>Jenkins will detect the commit and kick off a new build. &nbsp;I can log into the Jenkins web interface and watch the progress of the build. &nbsp;It's possible the build will fail, and other developers will grumble at me until I fix the now broken dev environment. &nbsp;Let's say I did just that.</li><li>If I think it might be a while before I'm able to fix my change, I'll use "<span style="font-family: Courier New, Courier, monospace;">git revert &lt;SHA code&gt;</span>" to undo the commit then quickly push that to dev. &nbsp;Either way, I'll again checkout my larger-pics branch, <span style="font-family: Courier New, Courier, monospace;">git rebase dev</span>, then make changes, <span style="font-family: Courier New, Courier, monospace;">git pull origin dev</span>, <span style="font-family: Courier New, Courier, monospace;">git rebase dev</span>, <span style="font-family: Courier New, Courier, monospace;">git checkout dev</span>, <span style="font-family: Courier New, Courier, monospace;">git merge larger-pics</span>, <span style="font-family: Courier New, Courier, monospace;">git push origin dev</span>. &nbsp;Let's say Jenkins gives me the thumbs up now.</li><li>Next stage is the code review. &nbsp;I'll log into Crucible and advertise my list of commits in the dev branch for others to review. &nbsp;I can make modifications based on their feedback if necessary.</li></ul><br /><br /><span id="submitting-to-qa"></span><br /><h4>Submitting to QA</h4><br />Let's say both Jenkins and my fellow developers are happy. &nbsp;It's time to submit my code to QA. &nbsp;The QA branch is automatically deployed by Jenkins to the QA servers, a pristine environment meant to better reflect what actually is accessed by New York Magazine's readers. &nbsp;We have some dedicated QA experts to systematically test my functionality to make sure I didn't unintentionally break something. &nbsp;If there are no QA experts available, QA might be done by another developer if the feature is sufficiently urgent.<br /><ul><li>I need to update my local QA branch so I can rebase my changes onto it, pushing fast-forward commits. &nbsp;I first type: <span style="font-family: Courier New, Courier, monospace;">git pull origin qa</span></li><li>Then I change to my larger-pics branch: <span style="font-family: Courier New, Courier, monospace;">git checkout larger-pics</span></li><li>It's time to rebase my commits onto the qa branch, rather than dev, which can be polluted by the works in progress of other developers. &nbsp;I type: <span style="font-family: Courier New, Courier, monospace;">git rebase -i qa</span>, creating a combined commit message describing my entire set of changes. &nbsp;I now have a branch that is the same as QA, plus one fast-forwardable commit that reflects all of my changes.</li><li>I add my branch to the remote repository: <span style="font-family: Courier New, Courier, monospace;">git push -u origin larger-pics</span></li><li>I go to the repository on Github and <a href="https://help.github.com/articles/creating-a-pull-request">create a pull request</a>,&nbsp;requesting my larger-pics branch be merged into the qa branch.</li></ul><br /><br /><span id="the-project-maintainer"></span><br /><h4>The Project Maintainer</h4><br />At this point, it's out of my hands, for the time being. &nbsp;However, the project has a "maintainer" assigned.<br /><br /><ul><li>The maintainer can first use the Github interface to&nbsp;<a href="https://help.github.com/articles/using-pull-requests">see the changes</a>. &nbsp;The maintainer can give a last check for the code.</li><li>If approved, the maintainer must <a href="https://help.github.com/articles/merging-a-pull-request">merge the branch</a>&nbsp;targeted by the pull request to the qa branch. &nbsp;If the commit will have no conflicts, Github's interface is sufficient to merge in the change. &nbsp;Otherwise, the maintainer either can reject the change, requesting for the original developer of the change to rebase the branch again and resolve the conflict before creating a new pull request. &nbsp;Otherwise, the maintainer can checkout the branch locally and resolve the merge, rather than the original developer doing it.</li><li>The maintainer commits the merged change and updates the JIRA story to "Submitted to QA".</li><li>If QA finds a bug, they will change the JIRA status to "Failed QA". &nbsp;The maintainer will checkout the QA branch and use "git revert" to roll back the change, then will reassign the JIRA ticket back to the original developer.</li><li>If QA approves the change however, they will change the JIRA status to "Passed QA".</li></ul><br /><br /><span id="release-day"></span><br /><h4>Release Day</h4><br />At regular intervals, a development team will release a set of features that are ready and desired. &nbsp;A release consists of:<br /><ul><li>A developer merging QA-approved changes from the QA branch to the staging branch.</li><li>Members of the team having a last look at the change's functionality in the staging environment.</li><li>The developer of a change, after confirming that it works correctly in staging, merges the change into the prod branch before a designated release cutoff time.</li><li>The developer changes the status of the JIRA story to "Resolved"</li><li>The system administrators will deploy a build including the last commit before the cutoff time. &nbsp;For New York Magazine, this entails a brief period of down-time, so the release is coordinated with the editors and others who potentially will be affected.</li></ul><br /><span id="whats-not-set-in-stone"></span><br /><h4>What's Not Set in Stone</h4><br />That's a summary of how I work, and although everything is "sensible", it's a bit in flux. &nbsp;These are things which could be changed:<br /><br /><ul><li>We can get rid of the staging environment, and merge directly from QA. &nbsp;I see the value in this extra level of testing, but I believe four stages is a bit too cumbersome.</li><li>A project does not necessarily need a maintainer, and if we use Crucible, perhaps not even pull requests. &nbsp;A developer can merge his change directly into the QA branch and submit the story to QA on his/her own. &nbsp;I prefer to have a project maintainer.</li><li>We can get rid of Crucible, and just use the code review system in Github. &nbsp;It might not be as feature-filled, but if we use pull requests, it's readily available and could streamline the process. &nbsp;I like Crucible, although it might be worth exploring eliminating this redundancy.</li></ul><br /><br /><span id="conclusion"></span><br /><h3>Conclusion</h3><br />After years of using many other version control systems, Git has proven to be the one that<br />makes the most sense. &nbsp;It's certainly not dependent on a reliable internet connection. &nbsp;It's fast. &nbsp;It's very flexible. &nbsp;After over 20 years of professional software development, I conclude Git is an absolutely indispensable tool.</div></div>


<p></div>
</div></p>
]]></content>
  </entry>
  
</feed>
